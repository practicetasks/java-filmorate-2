# Техническое задание

Настало время улучшить `Filmorate`. Чтобы составлять рейтинг фильмов, нужны отзывы пользователей. А для улучшения
рекомендаций по просмотру хорошо бы объединить пользователей в комьюнити.

### Архитектура

Начнём с переработки архитектуры. Сейчас вся логика приложения спрятана в контроллерах — изменим это. Вынесите хранение
данных о фильмах и пользователях в отдельные классы. Назовём их **«хранилищами»** (англ. _storage_) — так будет сразу
понятно,
что они делают.

- Создайте интерфейсы `FilmStorage` и `UserStorage`, в которых будут определены методы добавления, удаления и
  модификации
  объектов.
- Создайте классы `InMemoryFilmStorage` и `InMemoryUserStorage`, имплементирующие новые интерфейсы, и перенесите туда
  всю
  логику хранения, обновления и поиска объектов.
- Добавьте к `InMemoryFilmStorage` и `InMemoryUserStorage` аннотацию `@Component`, чтобы впоследствии пользоваться
  внедрением
  зависимостей и передавать хранилища сервисам.

### Новая логика

Пока у приложения нет никакой бизнес-логики, кроме валидации сущностей. Обеспечим возможность пользователям добавлять
друг друга в друзья и ставить фильмам лайки.

- Создайте `UserService`, который будет отвечать за такие операции с пользователями, как добавление в друзья, удаление
  из друзей, вывод списка общих друзей. Пока пользователям не надо одобрять заявки в друзья — добавляем сразу. То есть
  если Лена стала другом Саши, то это значит, что Саша теперь друг Лены.
- Создайте `FilmService`, который будет отвечать за операции с фильмами, — добавление и удаление лайка, вывод 10
  наиболее популярных фильмов по количеству лайков. Пусть пока каждый пользователь может поставить лайк фильму только
  один раз.
- Добавьте к ним аннотацию `@Service` — тогда к ним можно будет получить доступ из контроллера.

<details>
<summary>Подсказка: про список друзей и лайки</summary>

Есть много способов хранить информацию о том, что два пользователя являются друзьями. Например, можно создать свойство
`friends` в классе пользователя, которое будет содержать список его друзей. Вы можете использовать такое решение или
придумать своё.
Для того чтобы обеспечить уникальность значения (мы не можем добавить одного человека в друзья дважды), проще всего
использовать для хранения `Set<Long>` c id друзей. Таким же образом можно обеспечить условие «один пользователь — один
лайк» для оценки фильмов.
</details>

### Зависимости

Переделайте код в контроллерах, сервисах и хранилищах под использование внедрения зависимостей.

- Используйте аннотации `@Service`, `@Component`, `@Autowired`. Внедряйте зависимости через конструкторы классов.
- Классы-сервисы должны иметь доступ к классам-хранилищам. Убедитесь, что сервисы зависят от интерфейсов
  классов-хранилищ, а не их реализаций. Таким образом в будущем будет проще добавлять и использовать новые реализации с
  другим типом хранения данных.
- Сервисы должны быть внедрены в соответствующие контроллеры.

<details>
<summary>Подсказка: @Service vs @Component</summary>

`@Component` — аннотация, которая определяет класс как управляемый Spring. Такой класс будет добавлен в контекст
приложения при сканировании. `@Service` не отличается по поведению, но обозначает более узкий спектр классов — такие,
которые содержат в себе бизнес-логику и, как правило, не хранят состояние.
</details>

### Полный REST

Дальше стоит заняться контроллерами и довести API до соответствия REST.

- С помощью аннотации `@PathVariable` добавьте возможность получать каждый фильм и данные о пользователях по их
  уникальному идентификатору: `GET .../users/{id}`.
- Добавьте методы, позволяющие пользователям добавлять друг друга в друзья, получать список общих друзей и лайкать
  фильмы. Проверьте, что все они работают корректно.
    - `PUT /users/{id}/friends/{friendId}` — добавление в друзья.
    - `DELETE /users/{id}/friends/{friendId}` — удаление из друзей.
    - `GET /users/{id}/friends` — возвращаем список пользователей, являющихся его друзьями.
    - `GET /users/{id}/friends/common/{otherId}` — список друзей, общих с другим пользователем.
    - `PUT /films/{id}/like/{userId}` — пользователь ставит лайк фильму.
    - `DELETE /films/{id}/like/{userId}` — пользователь удаляет лайк.
    - `GET /films/popular?count={count}` — возвращает список из первых count фильмов по количеству лайков. Если значение
      параметра count не задано, верните первые 10.

- Убедитесь, что ваше приложение возвращает корректные HTTP-коды.
    - 400 — если ошибка валидации: `ValidationException`;
    - 404 — для всех ситуаций, если искомый объект не найден;
    - 500 — если возникло исключение.

Настройте `ExceptionHandler` для централизованной обработки ошибок.


### Тестирование
Убедитесь, что приложение работает, — протестируйте его с помощью Postman: [postman.json](postman.json).
